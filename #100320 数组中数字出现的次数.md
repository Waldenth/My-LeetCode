#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)



一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

 

**示例 1：**

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

**示例 2：**

```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```



本题要求的时间复杂度和空间复杂度要求都非常苛刻，因此不能简单考虑暴力比较普通算术的解法.因此可以考虑尝试使用位运算进行求解.

与重复数字有密切关系的逻辑位运算是异或运算，联想异或基本性质：

**对于任一向量a,有a^a=0**  ,异或也可用于数字交换函数:

```c
/* CSAPP: ex 2.10 */
void inplace_swap(int*x,int*y){
	*y=*x^*y;
    *x=*x^*y;
    *y=*x^*y;
}
```



此外，根据代数基本知识可以证明:**在一个位数确定的补码数域中,异或运算可以构成一个阿贝尔群,群单位元是0**，因此运算与数字顺序无关，与运算顺序无关.

因此，数组中所有数字进行异或，得到的结果`xorAll`就是**两个要找的数字的异或结果**(因为其他数字对称异或结果是单位元0).

下面是补码性质定理. **在一个位数确定的补码数域中，有：**

**定理1:补码求反+1==该补码表示的数值的相反数数值的补码**

**定理2: <定理1>的运算可以形容为：对于一个补码的右起第一个1的左边全部位求反**

**定理3:原码和补码在正数范围内表示相同(原码有正负0)，负数范围内，由定理1、2，原码求对应补码(如果有)可以:**

​	**1、原码变符号位取正数，得到正数(补码)，再全体求反+1**

​	**2、右起第一个1和"符号位"之前的位数全部求反**

​	**补码求原码(如果有):**

​	**正数补码即原码，负数按照定理1、2求得相反数(正数)的补码，根据定理3，正数的补码也就是原码，再把原	码的符号位置为1，就是负数补码的对应原码**



根据定理1、2，可以对`xorAll`取负，与原`xorAll`进行**与**运算，得到的结果的二进制表示就是原`xorAll`右起第一个`1`之外的所有位全为0的数。根据异或性质，所要寻找的两个数这个位肯定不相同.

因此，再次数组所有元素进行遍历，分别与进行`new xorAll`进行**与**运算，将结果分为0和非0两组，两个寻找的数字必定分别在这两组中，分别异或，得出结果.

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int []results=new int[2];
        int xorAll=nums[0];
        for(int i=1;i<nums.length;i++){
            xorAll=xorAll^nums[i];
        }
        //得到xorAll二进制的右起第一个1,其余位全0的数
        xorAll=xorAll&(-1*xorAll);   //取相反数在补码中等价于从右起第一个1后全体求反
        for(int i=0;i<nums.length;i++){
            if((nums[i]&xorAll)==0){    //运算优先级
                results[0]^=nums[i];
            }else{
                results[1]^=nums[i];
            }
        }
        return results;
    }
}
```



